module Meow.Transfer where

import Meow.Token
import Splice.Api.Token.TransferInstructionV1 qualified as Transfer
import Splice.Api.Token.MetadataV1 qualified as Meta

-- UTILS

assertTransferStatus : Transfer.TransferInstructionStatus -> ()
assertTransferStatus status = do
    assertMsg "Transfer instruction must be pending receiver acceptance" (status == Transfer.TransferPendingReceiverAcceptance)

-- TEMPLATES

template MeowTransferFactory
  with
    admin : Party
    transfer : Transfer.Transfer
  where
    signatory admin, transfer.sender

    interface instance Transfer.TransferFactory for MeowTransferFactory where
      view = Transfer.TransferFactoryView with
        admin
        meta = Meta.emptyMetadata

      transferFactory_transferImpl self transfer = do
        assertMsg "Expected admin does not match" (transfer.expectedAdmin == admin)
        assertMsg "executeBefore must be after requestedAt" (transfer.executeBefore > transfer.requestedAt)

        transferInstructionCid <- create MeowTransferInstruction with
          admin
          transfer
          status = Transfer.TransferPendingReceiverAcceptance
          meta = Meta.emptyMetadata

        Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Pending with
            transferInstructionCid
          senderChangeCids = [] -- we don't send back the change to the sender as the pet ownership is not divisible - we send it all to the receiver
          meta = Metadata.emptyMetadata

      transferFactory_publicFetchImpl self fetch = do
        assertMsg "Expected admin does not match" (fetch.expectedAdmin == admin)
        Transfer.TransferFactoryView with
          admin
          meta = Meta.emptyMetadata

template MeowTransferInstruction
  with
    admin : Party
    transfer : Transfer.Transfer
    status : Transfer.TransferInstructionStatus
    meta : Meta.Metadata
  where
    signatory admin
    observer transfer.receiver, transfer.sender

    interface instance Transfer.TransferInstruction for MeowTransferInstruction where
      view = Transfer.TransferInstructionView with
        transfer
        status
        meta

      transferInstruction_acceptImpl self accept = do
        -- Status must be set to 'TransferPendingReceiverAcceptance' before a transfer can be executed
        assertTransferStatus status

        -- Check transfer hasn't expired
        now <- getTime
        assertMsg "Transfer has expired" (transfer.executeBefore > now)

        let senderToken = head transfer.inputHoldingCids

        -- Create the MeowToken for the receiver
        receiverTokenCid <- create MeowToken with
          admin
          owner = transfer.transfer.receiver
          meta = senderToken.meta

        -- Archive sender's token
        archive senderToken

        Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Completed with
            receiverHoldingCids = [receiverTokenCid]
          senderChangeCids = []
          meta = Meta.emptyMetadata

      transferInstruction_rejectImpl self reject = do
        -- Status must be set to 'TransferPendingReceiverAcceptance' before a transfer can be executed
        assertTransferStatus status

        Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Meta.emptyMetadata

      transferInstruction_withdrawImpl self withdraw = do
        Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Meta.emptyMetadata

      transferInstruction_updateImpl self update = do
        abort "Cannot update a transfer instruction"
