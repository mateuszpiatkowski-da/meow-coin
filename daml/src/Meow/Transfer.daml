module Meow.Transfer where

import Meow.Holding
import Splice.Api.Token.TransferInstructionV1 qualified as Transfer
import Splice.Api.Token.HoldingV1 qualified as Holding
import Splice.Api.Token.MetadataV1 qualified as Meta
import DA.List qualified as List

-- UTILS

assertTransferStatus : Transfer.TransferInstructionStatus -> Update ()
assertTransferStatus status = do
    assertMsg "Transfer instruction must be pending receiver acceptance" (status == Transfer.TransferPendingReceiverAcceptance)

-- TEMPLATES

template MeowTransferFactory
  with
    admin : Party
  where
    signatory admin

    interface instance Transfer.TransferFactory for MeowTransferFactory where
      view = Transfer.TransferFactoryView with
        admin
        meta = Meta.emptyMetadata

      transferFactory_transferImpl self transferRequest = do
        assertMsg "Expected admin does not match" (transferRequest.expectedAdmin == admin)
        assertMsg "executeBefore must be after requestedAt" (transferRequest.transfer.executeBefore > transferRequest.transfer.requestedAt)

        concreteTransferInstructionCid <- create MeowTransferInstruction with
          admin
          transfer = transferRequest.transfer
          status = Transfer.TransferPendingReceiverAcceptance
          meta = Meta.emptyMetadata

        let transferInstructionCid = toInterfaceContractId @Transfer.TransferInstruction concreteTransferInstructionCid

        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Pending with
            transferInstructionCid
          senderChangeCids = [] -- we don't send back the change to the sender as the pet ownership is not divisible - we send it all to the receiver
          meta = Meta.emptyMetadata

      transferFactory_publicFetchImpl self fetch = do
        assertMsg "Expected admin does not match" (fetch.expectedAdmin == admin)
        pure Transfer.TransferFactoryView with
          admin
          meta = Meta.emptyMetadata

template MeowTransferInstruction
  with
    admin : Party
    transfer : Transfer.Transfer
    status : Transfer.TransferInstructionStatus
    meta : Meta.Metadata
  where
    signatory admin
    observer transfer.receiver, transfer.sender

    interface instance Transfer.TransferInstruction for MeowTransferInstruction where
      view = Transfer.TransferInstructionView with
        transfer
        status
        originalInstructionCid = None
        meta

      transferInstruction_acceptImpl self accept = do
        -- Status must be set to 'TransferPendingReceiverAcceptance' before a transfer can be executed
        assertTransferStatus status

        -- Check transfer hasn't expired
        now <- getTime
        assertMsg "Transfer has expired" (transfer.executeBefore > now)

        let senderTokenCid = List.head transfer.inputHoldingCids

        -- Fetch the sender's token to get its metadata
        senderTokenView <- view <$> fetch senderTokenCid

        -- Create the MeowToken for the receiver
        concreteReceiverTokenCid <- create MeowToken with
          admin
          owner = transfer.receiver
          meta = senderTokenView.meta

        let receiverTokenCid = toInterfaceContractId @Holding.Holding concreteReceiverTokenCid

        -- Archive sender's token
        archive senderTokenCid

        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Completed with
            receiverHoldingCids = [receiverTokenCid]
          senderChangeCids = []
          meta = Meta.emptyMetadata

      transferInstruction_rejectImpl self reject = do
        -- Status must be set to 'TransferPendingReceiverAcceptance' before a transfer can be executed
        assertTransferStatus status

        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Meta.emptyMetadata

      transferInstruction_withdrawImpl self withdraw = do
        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Meta.emptyMetadata

      transferInstruction_updateImpl self update = do
        abort "Cannot update a transfer instruction"
