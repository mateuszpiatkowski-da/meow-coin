module Meow.Transfer where

import Meow.Holding
import Meow.Metadata
import Splice.Api.Token.TransferInstructionV1 qualified as Transfer
import Splice.Api.Token.HoldingV1 qualified as Holding
import DA.List qualified as List

-- UTILS

assertTransferStatus : Transfer.TransferInstructionStatus -> Update ()
assertTransferStatus status = do
  assertMsg "Transfer instruction must be pending receiver acceptance" (status == Transfer.TransferPendingReceiverAcceptance)

-- TEMPLATES

template MeowTransferFactory
  with
    admin : Party
  where
    signatory admin

    interface instance Transfer.TransferFactory for MeowTransferFactory where
      view = Transfer.TransferFactoryView with
        admin
        meta = meowMeta

      transferFactory_transferImpl self transferRequest = do
        assertMsg "Expected admin does not match" (transferRequest.expectedAdmin == admin)
        assertMsg "executeBefore must be after requestedAt" (transferRequest.transfer.executeBefore > transferRequest.transfer.requestedAt)

        concreteTransferInstructionCid <- create MeowTransferInstruction with
          admin
          transfer = transferRequest.transfer
          status = Transfer.TransferPendingReceiverAcceptance

        let transferInstructionCid = toInterfaceContractId @Transfer.TransferInstruction concreteTransferInstructionCid

        -- check if the sender sends too much
        senderInputAmounts <- mapA (\holdingCid -> do
          holdingView <- view <$> fetch holdingCid
          pure holdingView.amount) transferRequest.transfer.inputHoldingCids
        let senderInputAmountSum : Decimal = sum senderInputAmounts
        let senderChange = senderInputAmountSum - transferRequest.transfer.amount

        -- create change for sender (if needed)
        senderChangeCids <- if senderChange > 0.0 then do
          concreteChangeCid <- create MeowToken with
            admin
            owner = transferRequest.transfer.sender
            amount = senderChange
          let changeHoldingCid = toInterfaceContractId @Holding.Holding concreteChangeCid
          pure [changeHoldingCid]
          else pure []

        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Pending with
            transferInstructionCid
          senderChangeCids
          meta = meowMeta

      transferFactory_publicFetchImpl self fetch = do
        assertMsg "Expected admin does not match" (fetch.expectedAdmin == admin)
        pure Transfer.TransferFactoryView with
          admin
          meta = meowMeta

template MeowTransferInstruction
  with
    admin : Party
    transfer : Transfer.Transfer
    status : Transfer.TransferInstructionStatus
  where
    signatory admin
    observer transfer.receiver, transfer.sender

    interface instance Transfer.TransferInstruction for MeowTransferInstruction where
      view = Transfer.TransferInstructionView with
        transfer
        status
        originalInstructionCid = None
        meta = meowMeta

      transferInstruction_acceptImpl self accept = do
        -- Status must be set to 'TransferPendingReceiverAcceptance' before a transfer can be executed
        assertTransferStatus status

        -- Check transfer hasn't expired
        now <- getTime
        assertMsg "Transfer has expired" (transfer.executeBefore > now)

        let senderTokenCid = List.head transfer.inputHoldingCids

        -- Fetch the sender's token
        senderTokenView <- view <$> fetch senderTokenCid

        -- Create the MeowToken for the receiver
        concreteReceiverTokenCid <- create MeowToken with
          admin
          owner = transfer.receiver
          amount = transfer.amount

        let receiverTokenCid = toInterfaceContractId @Holding.Holding concreteReceiverTokenCid

        -- Archive sender's token
        archive senderTokenCid

        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Completed with
            receiverHoldingCids = [receiverTokenCid]
          senderChangeCids = []
          meta = meowMeta

      transferInstruction_rejectImpl self reject = do
        -- Status must be set to 'TransferPendingReceiverAcceptance' before a transfer can be executed
        assertTransferStatus status

        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = meowMeta

      transferInstruction_withdrawImpl self withdraw = do
        pure Transfer.TransferInstructionResult with
          output = Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = meowMeta

      transferInstruction_updateImpl self update = do
        abort "Cannot update a transfer instruction"
