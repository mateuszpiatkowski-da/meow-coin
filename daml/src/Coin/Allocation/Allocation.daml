module Coin.Allocation.Allocation where

import Splice.Api.Token.AllocationV1 qualified as Alloc
import Splice.Api.Token.MetadataV1 qualified as Meta
import Coin.Holding
import Splice.Api.Token.HoldingV1 qualified as Holding
import Coin.Util qualified as Util
import DA.Foldable qualified as Foldable

template CoinAllocation
  with
    admin : Party
    settlement : Alloc.SettlementInfo
    transferLeg : Alloc.TransferLeg
    transferLegId : Text
    senderHoldingCids : [ContractId Holding.Holding]
  where
    signatory settlement.executor, admin
    observer transferLeg.sender, transferLeg.receiver

    interface instance Alloc.Allocation for CoinAllocation where
      view = Alloc.AllocationView with
        allocation = Alloc.AllocationSpecification with
          settlement
          transferLegId
          transferLeg
        holdingCids = senderHoldingCids
        meta = Meta.emptyMetadata

      allocation_executeTransferImpl this executeRequest = do
        now <- getTime
        assertMsg "Settlement deadline has passed" (settlement.settleBefore >= now)

        -- calculate the sender change and create a return token (if needed)
        senderChangeAmount <- Util.calculateSenderChange senderHoldingCids transferLeg.amount

        assertMsg "Insufficient funds: sender did not provide enough resources" (senderChangeAmount >= 0.0)

        senderChangeHoldingCids <- if senderChangeAmount > 0.0 then do
          testCid <- create CoinToken with
            owner = transferLeg.sender
            admin = settlement.executor
            amount = senderChangeAmount
            createdAt = now
          let holdingCid = Util.testTokenToHoldingCid testCid
          pure [holdingCid]
          else pure []

        -- create receiver holding token
        receiverHoldingCid <- create CoinToken with
          admin = settlement.executor
          owner = transferLeg.receiver
          amount = transferLeg.amount
          createdAt = now

        let receiverHoldingCids = [Util.testTokenToHoldingCid receiverHoldingCid]

        -- archive all used sender's holding contracts
        Foldable.forA_ senderHoldingCids archive

        pure Alloc.Allocation_ExecuteTransferResult with
          senderHoldingCids = senderChangeHoldingCids
          receiverHoldingCids
          meta = Meta.emptyMetadata

      allocation_cancelImpl this cancelRequest = do
        pure Alloc.Allocation_CancelResult with
          senderHoldingCids = [] -- we don't lock the holdings in the allocation, so there is no need to send this back to the user
          meta = Meta.emptyMetadata

      allocation_withdrawImpl this withdrawRequest = do
        pure Alloc.Allocation_WithdrawResult with
          senderHoldingCids = [] -- we don't lock the holdings in the allocation, so there is no need to send this back to the user
          meta = Meta.emptyMetadata

